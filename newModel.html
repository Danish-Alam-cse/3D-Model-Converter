<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Add a 3D model</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<!-- <link href="https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.js"></script> -->

<script src="https://apis.mapmyindia.com/advancedmaps/api/6afd17c1d7c643cfd936980a152f4523/map_sdk?layer=vector&v=2.0&callback=initMap1" defer async></script>

<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; height:100vh}
</style>
</head>
<body>
<script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
<div id="map"></div>
<script>
    var map;
              function initMap1(){
                map = new MapmyIndia.Map('map', {
                    center: [28.61, 77.23],
                    zoomControl: true,
                    zoom:18,
                    location: true,
                    backgroundColor:'red',
                    draggable: true,
                });

                const modelOrigin = [77.23,28.61];
                const modelAltitude = 0;
                const modelRotate = [Math.PI / 2, 0, 0];

    const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
        modelOrigin,
        modelAltitude
    );

    // transformation parameters to position, rotate and scale the 3D model onto the map
    const modelTransform = {
        translateX: modelAsMercatorCoordinate.x,
        translateY: modelAsMercatorCoordinate.y,
        translateZ: modelAsMercatorCoordinate.z,
        rotateX: modelRotate[0],
        rotateY: modelRotate[1],
        rotateZ: modelRotate[2],
        /* Since the 3D model is in real world meters, a scale transform needs to be
         * applied since the CustomLayerInterface expects units in MercatorCoordinates.
         */
        scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
    };

    const THREE = window.THREE;

    // configuration of the custom layer for a 3D model per the CustomLayerInterface
    const customLayer = {
        id: '3d-model',
        type: 'custom',
        renderingMode: '3d',
        onAdd: function (map, gl) {
            this.camera = new THREE.Camera();
            this.scene = new THREE.Scene();

            // create two three.js lights to illuminate the model
            // const directionalLight = new THREE.DirectionalLight(0xffffff);
            // directionalLight.position.set(0, -70, 100).normalize();

            
        
            var light = new THREE.AmbientLight(0xffffff);
            this.scene.add(light);

            // const directionalLight2 = new THREE.DirectionalLight(0xffffff, 9.0, 1000);
            // directionalLight2.position.set(0, 70, 100).normalize();
            // this.scene.add(directionalLight2);
            
//             const floor = new THREE.Mesh(
//              new THREE.PlaneBufferGeometry(50, 50),
//             new THREE.MeshPhongMaterial({
//     color: "gray"
//   })
// );

            // use the three.js GLTF loader to add the 3D model to the three.js scene
            const loader = new THREE.GLTFLoader();
            loader.load(
                'DEL_RPC_21.gltf',
                
                (gltf) => {
                    this.scene.add(gltf.scene);
                }
            );
            this.map = map;

            // use the Mapbox GL JS map canvas for three.js
            this.renderer = new THREE.WebGLRenderer({
                canvas: map.getCanvas(),
                context: gl,
                antialias: true
            });

            this.renderer.autoClear = false;
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFShadowMap;
            this.directionalLight2.castShadow = true;
            this.directionalLight2.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 100, 1, 500, 1000 ) );
	        this.directionalLight2.shadow.bias = 0.0001;    
            this.directionalLight2.shadow.mapSize.width = 2048 * 2;
            this.directionalLight2.shadow.mapSize.height = 2048 * 2;
            this.scene.add(directionalLight2);

            this.floor.receiveShadow = true;
            this.loader.castShadow = true;

            
            },
            render: function (gl, matrix) {
            var m = new THREE.Matrix4().fromArray(matrix);
            var l = new THREE.Matrix4().makeTranslation( modelTransform.translateX, modelTransform.translateY,modelTransform.translateZ ).scale(new THREE.Vector3(modelTransform.scale, -modelTransform.scale, modelTransform.scale));
            this.camera.projectionMatrix = m.multiply(l);
            this.renderer.resetState();
            this.renderer.render(this.scene, this.camera);
            this.map.triggerRepaint();
        }
    };
    map.on('load',function(){
            map.addLayer(customLayer);
        })


                // map.addListener("click",function me(){
                //     console.log('clicked by me');
                // })
                // map.addListener('dblclick', function () { console.log("hello")});
              }
            

    console.log(randomVAlue);
    
  
</script>

</body>
</html>